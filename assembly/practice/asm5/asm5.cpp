/*
Самая сложная задача: ввести с клавитуры ровно 10 чисел целого типа, используя язык С и найти их сумму.
*/
#include <iostream>

int main()
{
	int a, sum = 0, counter;
	bool indicator;
	int zu[10];

	for (int i = 0; i < 10; i++) {
		std::cin >> a;
		zu[i] = a;
	}
	for (int i = 0; i < 10; i++) {
		sum += zu[i];
		/*
		Сумму будем находить в eax
		Дедушку никто не любит. Потому что дедушка всё время пристаёт и говорит про основное действие.
		add eax, адрес очередного элемента. Косвенный способ адресации. Адрес - номер байта, определяется с использованием базовых
		и индексных регистров, в частности адрес очередного элемента может быть записан add eax, [zu + esi]
		*/
	}

	std::cout << sum << "\n";

	__asm {

		mov eax, 0
		mov esi, 0
		mov ecx, 10

		cicle:
		add eax, [zu + esi]
			add esi, 4
			loop cicle

			mov sum, eax
	}

	counter = 0;
	for (int i = 0; i < 9; i++) {
		if (zu[i] * zu[i + 1] < 0)
			counter = counter + 1;
	}

	std::cout << sum << "\nПеремен знаков - " << counter;

	__asm {
		mov counter, 0
		mov esi, 0
		mov ecx, 9

		povt:
		mov eax, [zu + esi + 0]
			mov edx, [zu + esi + 4]
			mul edx
			cmp eax, 0
			jge lesom
			add counter, 1
			lesom:
		add esi, 4
			loop povt
	}

	std::cout << "\n" << counter;
	/*
	Необходимо посчитать кол-во перемен знака в этом массиве. Если из 3, то перемен 0, если -1 2 -3, то 2 перемены знака.
	Если 1 2 -3 - кол-во 1.

	Замечание. Думать над решением задачи означает нарисовать целую страницу текста/рисунка, прежде чем что-то кодировать.

	Необходимо определить, является ли массив палиндромом
	*/

	/*indicator = true;
	for (int i = 0; i < 5; i++)
		if (zu[i] != zu[9 - i]) {
			indicator = false;
			break;
		}*/

		//indicator == true ? std::cout << "\nПалиндром!" : std::cout << "\nНе палиндром!";

	__asm {
		mov ecx, 5
		mov esi, 0
		mov edx, 36
		mov indicator, 1

		donbass:
		mov eax, [zu + esi]
			cmp eax, [zu + edx]
			je cont
			mov indicator, 0
			jmp program_end
			cont :
		add esi, 4
			sub edx, 4
			loop donbass

			program_end :

	}

	/*
	Использование esi и edi называется индексным способом адресации. Наряду с этим есть базовый способ адресации, при котором
	используется содержимое регистров edx и ebp, и есть базово-индексный способ адресации, када ebx и esi одновременно
	в частности можно использовать esi и ebx, если в самом начале поместить число 36 в ebx и в качестве изменений параметров
	цикла к esi и ebx добавлять по 4.
	Когда используется косвенная адресация, иногда бывает необходимо указывать длину сравниваемого поля
	если речь идёт о 4, то писать квалификатор длины dword - иногда помогает. При использовании базового
	спооба адресации или другого, в командах при обращении в память не может быть указано имя области памяти
	а указывается так называемое смещение, т е константа, которая указывает, насколько байт внутри программы
	отстоит то или иное поле. + 36 - смещение. Просто zu использовать нельзя. Чтобы использовать такой способ,
	существует команда загрузки адреса, которая является сокращением  от low exeсution -__---
	le ebx, [zu+36] будет загружен адрес памяти как zu 36
	*/
	indicator == true ? std::cout << "\nПалиндром!" : std::cout << "\nНе палиндром!";

	/*
	На дом. Осуществляем циклическую замену элементов местами, а именно 1 элемент на 10, 10 на 9, 9 на 8 и тд. Циклический сдвиг влево.
	если было 123 -> 231
	*/
}