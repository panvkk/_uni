/*
Получить программу, используя C++, которая позволяет получить от пользователя последовательность целых чисел, причём эта последовательность
оканчивается числом 0 и это число 0 не относится к элементам последовательности. Создать в оперативной памяти списочную структуру,
элементами которой являются введённые с клавиатуры числа в информационной часта, а в адресной части адрес следующего элемента последовательности.
При этом, списочная структура создаётся путём добавления вводимых чисел в хвост, т е очередной элемент списка добавляется в конец списка.
После построения указанной списочной структуры необходимо вывести на экран элементы этой структуры таким образом, чтобы на экране было
представла информационная часть, т е целое число, и адрес следующего элемента.

Замечание 1.
    Во 2 семестре тексты на языке C++ придётся составлять таким образом, как сейчас будет показано и никак иначе. При этом,
всё будет делаться по нужде, а именно, никаких заранее не к месту определения и использования переменных никаких присваиваний значений
этим переменным запрещается делать. Переменные и начальные значения для них будут оперделяться после того, как будет получена основная часть
текста. Начинать составление текста будем с основного действия. Основным действие называется такое действие,
которое состоит из 4 шагов: 

    (Первый выполняется со 2 одноверменно и предполагает выделение памяти и запоминание адреса выделенной области памяти.)

1) work = new node; - Выполняется 2 действия: в оперативной памяти выделяется столько, сколько надо для node и в work помещается адрес этой памяти
2) Заполнение инф части: число берётся с клавиатуры: std::cin >> work->info;
3) Разобраться со ссылками: необходимо в адресную часть элемента из указателя work поместить адрес NULL и сделать переброску адресной части
последнего или предыдущего элемента(curr). curr->ssylka = work; Адрес очередного элемента в переменной curr: curr = work;
 ^
 |
 B
 curr = work <-- И
Это основное действие, которое будет постоянно выполняться для каждого нового элемента добавляемого в конец списка 

До тех пор, пока не будет создан элемент с info = 0; --- while(curr->info) {}
Проверку обозначаем буквой О. 
Подготовка цикла: начальное значение для всех составляющих цикла(создать список из 1 элемента). 
head = new node;
std::cin >> head->info;
head->ssylka = NULL;
curr = head;


Следующая задача: 
В оперативной памяти создан список(продолжаем текст), который определяется тем, что в head находится адрес первого элемента, а в адресной последнего
элемента находится NULL. Необходимо вывести на экран последовательность друг за другом информационную часть и адресную часть элементов 
из списочной структуры.
*/
#include <iostream>

struct node {
    int info;
    node* ssylka;
};

int main() {
    setlocale(LC_ALL, "Russian");
    node* head; 
    node* work; 
    node* curr;
    int sum, count;
    int min_el, max_el;
    node* adr_min_el;
    node* adr_max_el;
    node* pred;
    bool induk;

    // Приветствие
    std::cout << "Добрый день, дедушка. Данная программа позволяет Вам ввести,"
     << " набрав на клавиатуре, последовательность чисел,\nоканчивающуюся нулём, после чего будет создан список в оперативной памяти, и на экран\n"
     << "будет выведена информационная и адресная часть каждого элемента списка.\nВводить числа можно через пробел или каждое число с новой строки(нажимая клавишу Ввод).\n";

    head = new node;
    std::cin >> head->info;
    curr = head;
    while(curr->info) {
        work = new node;
        std::cin >> work->info;
        work->ssylka = NULL;
        curr->ssylka = work;
        curr = work;
    }

    std::cout << "\nЭлементы списка, введённого с помощью клавиатуры. \n";
    curr = head; // Подготовка цикла.
    if(head->info == 0) {              // Проверка списка на пустоту
        std::cout << "Дедушка, Вы редиска! Список пуст!\n";
        system("pause");
    } 
    count = 1;
    while(curr->ssylka) {
        std::cout << count << " элемент списочной структуры: " << "информационная часть - " << curr->info << ", адресная часть - " << curr->ssylka << std::endl; // - Это буква В
        count = count + 1;
        curr = curr->ssylka;
    }

    
    curr = head; // Подготовка цикла 
    sum = 0;
    count = 0;
    while(curr->ssylka != NULL) {       // Нахождение среднего арифметического
        sum = sum + curr->info;
        count = count + 1;
        curr = curr->ssylka;
    }
    std::cout << "\nСреднее арифметическое выведенных на экран ранее чисел равно: " << sum/count << " - целых, " << sum%count << " - в остатке" << std::endl;
    // if(count == 0) {
    //     std::cout << "\nДедушка, Вы редиска! У вас в списке нет элементов.\n";
    // } else {
    // }


    curr = head; 
    min_el = head->info;
    max_el = head->info;
    adr_min_el = head;
    adr_max_el = head;

    while(curr->ssylka != NULL) {           // Нахождение максимального и минимального элементов
        if(min_el > curr->info) { 
            min_el = curr->info; 
            adr_min_el = curr;
        } 
        else if(max_el < curr->info) { 
            max_el = curr->info; 
            adr_max_el = curr;
        }
        curr = curr->ssylka;
    }
    std::swap(adr_max_el->info, adr_min_el->info);     // Меняю местами максимальный и минимальный элемент

    curr = head;
    std::cout << "\nСписок, в котором максимальное и минимальное значения поменены местами: \n";
    count = 1;
    while(curr->ssylka != NULL) {
        std::cout << count << " элемент списочной структуры: " << "информационная часть - " << curr->info << ", адресная часть - " << curr->ssylka << std::endl; // - Это буква В
        count = count + 1;
        curr = curr->ssylka;
    }  
    /*
    Задача. 
    Удалить из полученного списка максимальный и минимальный элемент. Полученный список вывести на экран
    */
    curr = head;
    pred = head;
    induk = true;
    
    if(head->info == min_el) {          // Если минимальный элемент находится в голове, то голова должна ссылаться на следующий элемент
        work = head;
        head = head->ssylka; 
        delete work;             // А сам минимальный удаляем
    } else
        while(induk)
            if(curr->info == min_el) {          // Удаляем минимальный элемент
                if(curr->ssylka != NULL) {  // Проверка, является ли минимальный элемент последним элементом списка
                    pred->ssylka = curr->ssylka;
                }    
                delete curr; 
                induk = false;
            } else {
                pred = curr;
                curr = curr->ssylka;
            }
        
    curr = head;
    pred = head;
    induk = true;
    
    if(head->info == max_el) {          // Если максимальный элемент находится в голове, то голова должна ссылаться на следующий
        work = head;
        head = head->ssylka; 
        delete work;            // А сам максимальный удаляем
    } else
        while(induk)                    
            if(curr->info == max_el) { 
                if(curr->ssylka != NULL) {  // Проверка, является ли максимальный элемент последним элементом списка
                    pred->ssylka = curr->ssylka;
                }             
                delete curr;            // Удаляем максимальный элемент
                induk = false;
            } else {
                pred = curr;
                curr = curr->ssylka;
            }
        
    curr = head; // Подготовка цикла.
    std::cout << "\nСписок, в котором минимальное и максимальное значения удалены: \n";
    count = 1;
    while(curr->ssylka != NULL) {
        std::cout << count << " элемент списочной структуры: " << "информационная часть - " << curr->info << ", адресная часть - " << curr->ssylka << std::endl; // - Это буква В
        count = count + 1;
        curr = curr->ssylka;
    }     
    /*
    Замечание.
    В использовании ЯЗА существуют правила хорошего тона. Эти правила хорошего тона наряду с оставлением комментариев предполагают, 
    что вход и выход из цикла должен осуществляться через заголовок цикла(никаких continue, break, switch).
    Будем пользовать следующей конструкцией 
    */
    /*
    Замечание 7.
    Из какого кинофильма взята фраза "Дам больно, дам больно!"(Буратино, Карабах-Барабах?). 
    Запомнить эту фразу, потому что препод будет её произносить и реализовывать в том случае, когда в тексте на C++ будет увиденно 
    два стоящих знака операции ++, --, -= и тд. ++ приводят к взрыву мозга.
    
    Замечание 8. 
    Определение значений нужно отделять от их объявлений.
    */
    system("pause");
}

/*
Замечание 2. 
Нет типа данных указатель. Указатель - запрещённое слово, ненормативная лексика. Так как по-хорошему, указатель - это переменная адресного типа,
то есть, это переменная, в которой может храниться адрес или ссылка на оперативную память. Тип переменной head - адресный тип
(будут находиться адреса областей памяти, причём, по этим адресам будут находиться значения типа node).

Замечание 3.
У дедушки на компьютере после ввода последовательности обычно всё исчезает.

Замечание 4. 
Таким образом, чтобы разобраться с циклом, необходимо в том, что нарисовано на доске поменять местами букву О и И и прочитать полученное слово. 
ПИВО! Нужно разобраться с пивом, чтобы выпить пиво.
Чтобы определить качество пива(цикла) необходимо посмотреть на пену пива. Правильное пиво это правильная подготовка цикла(буква П)
То есть, самое сложное в любом цикле это его подготовка.

Замечание 5. 
При написании текстов, те при записи алгоритмов на языке С++ необходимо делать всё, чтобы было при заполнении программы понятно даже дедушке,
то есть Константину Антоновичу, что делает копмьютер, какие данные должен вводить дедушка, и что получается в результате. Для текста,
которые набран, нужно внести изменения: 
Во-первых, вывести на экран сообщение следующего содержания: Добрый день, дедушка. Данная программа позволяет Вам ввести,
набрав на клавиатуре последовательность чисел, оканчивающуюся нулём, после чего будет создан список в оперативной памяти и на экран
будет выведена информационная и адресная часть каждого элемента списка. Вводить числа можно через пробел или каждое число с новой строки(нажимая клавишу Ввод).
А при выводе на экран результата необходимо указать, что выводится на экран, а именно: вывод каждого элемента сопровождать текстом
"первый элемент списочной структуры: информационная часть -    , ссылочная часть -    "
. . . 
. . .
Желательно и это есть ДЗ сделать так, чтобы на экран слова первый, второй, ... двадцатый, ... одная тысяча сто двадцать пятый 
выводилась словами. То есть нужно числу поставить соответствующий числительный(ДЗ через неделю(к 1 марта до 23:59)

Замечание 6. 
Обычно дьявол скрывается в мелочах. И ваша программа и программы должны бороться с этими дьяволами и выводить на экран соответствующие сообщения.
Например, в данной задаче дедушка может сразу ввести нуль. В этом случае следует сообщить: "Дедушка, Вы редиска! Вы не ввели ни
одного элемента списка." 

Про пояснительный текст - сделать до конца дня. 
Далее необходимо найти среднее арифметическое элементов списка.

Задача: 
В полученном списке в оперативной памяти найти максимальное и минимальное значение информационных частей, вывести их на экран,
после чего поменять их местами(максимальное и минимальное значение). Полученный список вывести на экран.




До конца дня доделать удаление максимального элемента и прислать на почту исходный текст, исполнимый модуль(который будет выполняться
и в котором можно будет посмотреть результат). А к субботе для полученного в памяти списка сделать сортировку по неубываюнию элементов 
списка. А до конца дня разобраться с вопросом, чтобы выполнялись все тесты, что нужно сделать для того, если минимальный и максимальный 
элемент находятся в голове списка(1 элемент списка).

*/