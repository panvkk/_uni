Чистые виртуальные функции и абстрактные классы
Иногда возникает необходимость определить класс, который не предполагает создания конкретных объектов. Например, класс
фигуры. В реальности есть конкретные фигуры: квадрат, прямоугольник, треугольник, круг и так далее. Однако абстрактной
фигуры самой по себе не существует. В то же время может потребоваться определить для всех фигур какой-то общий класс,
который будет содержать общую для всех функциональность. И для описания подобных сущностей используются абстрактные
классы.
Абстрактные классы - это классы, которые содержат или наследуют без переопределения хотя бы одну чистую виртуальную
функцию. Абстрактный класс определяет интерфейс для переопределения производными классами.
Что такое чистые виртуальные функции (pure virtual functions)? Это функции, которые не имеют определения. Цель подобных функций - просто
определить функционал без реализации, а реализацию определят производные классы. Чтобы определить виртуальную функцию как чистую, ее объявление завершается
значением "=0". Например, определим абстрактный класс, который представляет геометрическую фигуру:
1
2
3
4
5
6
class Shape
{
public:
virtual double getSquare() const = 0; // площадь фигуры
virtual double getPerimeter() const = 0; // периметр фигуры
};
Класс Shape является абстрактным, потому что он содержит как минимум одну чистую виртуальную функцию. А в данном
случае даже две таких функции - для вычисления площади и периметра фигуры. И ни одна из функций не имеет никакой
реализации. В данном случае обе функции являются константными, но это необязательно. Главное, чтобы любой производный
класс от Shape должен будет предоставить для этих функций свою реализацию.
При этом мы не можем создать объект абстрактного класса:
1 Shape shape{};
Для применения абстрактного класса запишем:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
#include <iostream>
class Shape
{
public:
virtual double getSquare() const = 0; // площадь фигуры
virtual double getPerimeter() const = 0; // периметр фигуры
};
class Rectangle : public Shape // класс прямоугольника
{
public:
Rectangle(double w, double h) : width(w), height(h)
{ }
double getSquare() const override
{
return width * height;
}
double getPerimeter() const override
{
return width * 2 + height * 2;
}
private:
double width; // ширина
double height; // высота
};
class Circle : public Shape // круг
{
public:
Circle(double r) : radius(r)
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
{ }
double getSquare() const override
{
return radius * radius * 3.14;
}
double getPerimeter() const override
{
return 2 * 3.14 * radius;
}
private:
double radius; // радиус круга
};
int main()
{
Rectangle rect{30, 50};
Circle circle{30};
std::cout << "Rectangle square: " << rect.getSquare() << std::endl;
std::cout << "Rectangle perimeter: " << rect.getPerimeter() << std::endl;
std::cout << "Circle square: " << circle.getSquare() << std::endl;
std::cout << "Circle perimeter: " << circle.getPerimeter() << std::endl;
}
Здесь определены два класса-наследника от абстрактного класса Shape - Rectangle (прямоугольник) и Circle (круг). При
создании классов-наследников все они должны либо определить для чистых виртуальных функций конкретную реализацию,
либо повторить объявление чистой виртуальной функции. Во втором случае производные классы также будут абстрактными.
В данном же случае и Circle, и Rectangle являются конкретными классами и реализуют все виртуальные функции.
Консольный вывод программы:
Rectangle square: 1500
Rectangle perimeter: 160
Circle square: 2826
Circle perimeter: 188.4
Стоит отметить, что абстрактный класс может определять и обычные функции и переменные, может иметь несколько конструкторов, но при этом нельзя создавать
объекты этого абстрактного класса. Например:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
#include <iostream>
class Shape
{
public:
Shape(int x, int y): x{x}, y{y}
{}
virtual double getSquare() const = 0; // площадь фигуры
virtual double getPerimeter() const = 0; // периметр фигуры
void printCoords() const
{
std::cout << "X: " << x << "\tY: " << y << std::endl;
}
private:
int x;
int y;
};
class Rectangle : public Shape // класс прямоугольника
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
{
public:
Rectangle(int x, int y, double w, double h) : Shape{x, y}, width(w), height(h)
{ }
double getSquare() const override
{
return width * height;
}
double getPerimeter() const override
{
return width * 2 + height * 2;
}
private:
double width; // ширина
double height; // высота
};
class Circle : public Shape // круг
{
public:
Circle(int x, int y, double r) : Shape{x, y}, radius(r)
{ }
double getSquare() const override
{
return radius * radius * 3.14;
}
double getPerimeter() const override
{
return 2 * 3.14 * radius;
}
48
49
50
51
52
53
54
55
56
57
58
59
private:
double radius; // радиус круга
};
int main()
{
Rectangle rect{0, 0, 30, 50};
rect.printCoords(); // X: 0 Y: 0
Circle circle{10, 20, 30};
circle.printCoords(); // X: 10 Y: 20
}
В данном случае класс Shape также имеет две переменных, конструктор, который устанавливает их значения, и невиртуальную
функцию, которая выводит их значения. В производных классах также необходимо вызвать этот конструктор. Однако объект
абстрактного класса с помощью его конструктора мы создать не можем.
ЗАДАНИЕ 1. НА ЗАНЯТИЯ: Вспомнить КЛАССЫ, КОТОРЫЕ ИСПОЛЬЗОВАЛИСЬ ПРИ РЕШЕНИИ ЗАДАЧИ ПО
ВЫЧИСЛЕНИЮ АЛГЕБРАИЧЕСКОГО ВЫРАЖЕНИЯ: Класс список, от которого НАСЛЕДОВАЛИСЬ КЛАССЫ Стек и Очередь.
НЕОБХОДИМО СДЕЛАТЬ ТАКИМ ОБРАЗОМ, ЧТОБЫ ФУНКЦИИ, КОТОРЫЕ ИСПОЛЬЗОВАЛИСЬ В КЛАССАХ Стек и Очередь,
БЫЛИ ОПРЕДЕЛЕНЫ ВИРТУАЛЬНЫМИ!!!! Используя полученные виртуальные функции и полученный класс СТЕК, решить
ЗАДАЧУ: Прочитать из файла текст, выделить из этого текста ТОЛЬКО ЧИСЛА (используя регулярные выражения), используя
стек ПЕРЕВЕРНУТЬ КАЖДОЕ ИЗ ЭТИХ ЧИСЕЛ, и получить в текстовом файле с тем же именем текст, в котором ВСЕ ЧИСЛА
ПЕРЕВЕРНУТЫ!!! Например, если в файле mrak.txt находится текст:
50.5202. Mama mila ramu365raz. 1 raz v den.
Papa mil okno ni razu.To est 0 raz.
Skolko bilo дней в году: 365 или 366
В результате необходимо получить текстовый файл с тем же именем mrak.txt, в котором должен быть текст:
05.2025. Mama mila ramu563raz. 1 raz v den.
Papa mil okno ni razu.To est 0 raz.
Skolko bilo дней в году: 563 или 663
При этом при выделении чисел использовать регулярные выражения, а при переворачивании – классы Mylist и Mystack с
виртуальными функциями таким образом, что очередная выделяемая цифра заталкивается в стек, а после того как все цифры
уже находятся в стеке, выталкиваются в обратном порядке. Обращайте внимание на то, что текст не ограничен по размеру, в
нем есть разделители, но числа могут быть не выделены разделителями, но могут быть и выделены